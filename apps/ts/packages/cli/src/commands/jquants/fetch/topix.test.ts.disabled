import { beforeEach, describe, expect, it, vi } from 'vitest';

// Mock modules with inline factories
vi.mock('../helpers', () => ({
  setupJQuantsClient: vi.fn(),
  displayDataSummary: vi.fn(),
}));

vi.mock('./display', () => ({
  displayTOPIX: vi.fn(),
}));

vi.mock('../../../utils/csv-exporter', () => ({
  CsvExporter: vi.fn(),
}));

vi.mock('..', () => ({
  handleApiError: vi.fn(),
}));

vi.mock('chalk', () => ({
  default: {
    red: (text: string) => text,
    green: (text: string) => text,
    yellow: (text: string) => text,
    cyan: (text: string) => text,
    white: (text: string) => text,
    gray: (text: string) => text,
  },
}));

// Create mock spinner implementation
const mockSpinnerFns = {
  start: vi.fn(),
  succeed: vi.fn(),
  fail: vi.fn(),
  warn: vi.fn(),
  stop: vi.fn(),
};

// Mock ora with actual mock functions that can be tracked
vi.mock('ora', () => ({
  default: vi.fn(() => {
    const spinner = {
      start: mockSpinnerFns.start.mockReturnThis(),
      succeed: mockSpinnerFns.succeed.mockReturnThis(),
      fail: mockSpinnerFns.fail.mockReturnThis(),
      warn: mockSpinnerFns.warn.mockReturnThis(),
      stop: mockSpinnerFns.stop.mockReturnThis(),
    };
    mockSpinnerFns.start.mockReturnValue(spinner);
    return spinner;
  }),
}));

// Import after mocking
import { CsvExporter } from '../../../utils/csv-exporter';
import { handleApiError } from '..';
import { displayDataSummary, setupJQuantsClient } from '../helpers';
import { displayTOPIX } from './display';
import { fetchTOPIX } from './topix';
import ora from 'ora';

// Test data constants
const mockTOPIXData = {
  topix: [
    {
      Date: '2025-01-10',
      Open: 2359.28,
      High: 2380.1,
      Low: 2335.58,
      Close: 2378.79,
    },
    {
      Date: '2025-01-11',
      Open: 2387.88,
      High: 2400.53,
      Low: 2382.79,
      Close: 2393.54,
    },
  ],
};

const mockFetchOptions = {
  from: '2025-01-01',
  to: '2025-01-31',
  output: './data',
  csv: false,
  json: true,
};

// Mock console
const mockConsole = {
  log: vi.fn(),
  error: vi.fn(),
};
global.console = mockConsole as unknown as Console;

// TODO: Fix mock setup for Bun runtime compatibility
// Tests are skipped due to vi.mock factory issues with Bun's module linking
describe.skip('fetchTOPIX', () => {
  let mockJQuantsClient: {
    getTOPIX: ReturnType<typeof vi.fn>;
  };
  let mockCsvExporter: {
    exportTOPIX: ReturnType<typeof vi.fn>;
    exportJSON: ReturnType<typeof vi.fn>;
  };

  beforeEach(() => {
    vi.clearAllMocks();

    mockJQuantsClient = {
      getTOPIX: vi.fn(),
    };

    mockCsvExporter = {
      exportTOPIX: vi.fn().mockReturnValue('/test/path/topix.csv'),
      exportJSON: vi.fn().mockReturnValue('/test/path/topix.json'),
    };

    // Setup mocks using type assertions
    (setupJQuantsClient as ReturnType<typeof vi.fn>).mockResolvedValue(mockJQuantsClient);
    (CsvExporter as unknown as ReturnType<typeof vi.fn>).mockImplementation(() => mockCsvExporter);
    (displayDataSummary as ReturnType<typeof vi.fn>).mockImplementation(() => {});
    (displayTOPIX as ReturnType<typeof vi.fn>).mockImplementation(() => {});
  });

  describe('successful data fetch', () => {
    beforeEach(() => {
      mockJQuantsClient.getTOPIX.mockResolvedValue(mockTOPIXData);
    });

    it('should fetch TOPIX data with default options', async () => {
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(ora).toHaveBeenCalledWith('Fetching TOPIX index data...');
      expect(setupJQuantsClient).toHaveBeenCalled();
      expect(mockJQuantsClient.getTOPIX).toHaveBeenCalledWith({
        from: options.from,
        to: options.to,
      });
      expect(mockSpinnerFns.succeed).toHaveBeenCalledWith(expect.stringContaining('Fetched 2 TOPIX records'));
    });

    it('should fetch TOPIX data with date range parameters', async () => {
      const options = {
        from: '2025-01-01',
        to: '2025-01-31',
        output: './data',
        csv: false,
        json: true,
      };

      await fetchTOPIX(options);

      expect(mockJQuantsClient.getTOPIX).toHaveBeenCalledWith({
        from: '2025-01-01',
        to: '2025-01-31',
      });
    });

    it('should fetch TOPIX data without date parameters', async () => {
      const options = { output: './data', csv: false, json: true };

      await fetchTOPIX(options);

      expect(mockJQuantsClient.getTOPIX).toHaveBeenCalledWith({});
    });

    it('should export data as CSV when csv option is true', async () => {
      const options = { ...mockFetchOptions, csv: true, output: './test-output' };

      await fetchTOPIX(options);

      expect(CsvExporter).toHaveBeenCalledWith('./test-output');
      expect(mockCsvExporter.exportTOPIX).toHaveBeenCalledWith(
        mockTOPIXData.topix,
        expect.stringMatching(/topix_\d{4}-\d{2}-\d{2}\.csv/)
      );
      expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('CSV exported to: /test/path/topix.csv'));
    });

    it('should export data as JSON when csv option is false', async () => {
      const options = { ...mockFetchOptions, csv: false, output: './test-output' };

      await fetchTOPIX(options);

      expect(CsvExporter).toHaveBeenCalledWith('./test-output');
      expect(mockCsvExporter.exportJSON).toHaveBeenCalledWith(
        mockTOPIXData.topix,
        expect.stringMatching(/topix_\d{4}-\d{2}-\d{2}\.json/)
      );
      expect(mockConsole.log).toHaveBeenCalledWith(expect.stringContaining('JSON exported to: /test/path/topix.json'));
    });

    it('should display data summary', async () => {
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(displayDataSummary).toHaveBeenCalledWith(mockTOPIXData.topix, displayTOPIX);
    });

    it('should generate filename with current date', async () => {
      const options = { ...mockFetchOptions, csv: true };
      const mockDate = new Date('2025-01-15T10:00:00Z');
      vi.setSystemTime(mockDate);

      await fetchTOPIX(options);

      expect(mockCsvExporter.exportTOPIX).toHaveBeenCalledWith(mockTOPIXData.topix, 'topix_2025-01-15.csv');

      vi.useRealTimers();
    });
  });

  describe('empty data response', () => {
    it('should handle empty TOPIX data', async () => {
      mockJQuantsClient.getTOPIX.mockResolvedValue({ topix: [] });
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(mockSpinnerFns.warn).toHaveBeenCalledWith(expect.stringContaining('No TOPIX data found'));
      expect(displayDataSummary).not.toHaveBeenCalled();
      expect(mockCsvExporter.exportTOPIX).not.toHaveBeenCalled();
      expect(mockCsvExporter.exportJSON).not.toHaveBeenCalled();
    });

    it('should handle null TOPIX data', async () => {
      mockJQuantsClient.getTOPIX.mockResolvedValue({ topix: null });
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(mockSpinnerFns.warn).toHaveBeenCalledWith(expect.stringContaining('No TOPIX data found'));
    });

    it('should handle undefined TOPIX data', async () => {
      mockJQuantsClient.getTOPIX.mockResolvedValue({});
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(mockSpinnerFns.warn).toHaveBeenCalledWith(expect.stringContaining('No TOPIX data found'));
    });
  });

  describe('error handling', () => {
    it('should handle API errors', async () => {
      const apiError = new Error('API connection failed');
      mockJQuantsClient.getTOPIX.mockRejectedValue(apiError);
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(mockSpinnerFns.fail).toHaveBeenCalled();
      expect(handleApiError).toHaveBeenCalledWith(apiError, 'Failed to fetch TOPIX data');
    });

    it('should handle authentication errors', async () => {
      const authError = new Error('Authentication failed');
      mockJQuantsClient.getTOPIX.mockRejectedValue(authError);
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(mockSpinnerFns.fail).toHaveBeenCalled();
      expect(handleApiError).toHaveBeenCalledWith(authError, 'Failed to fetch TOPIX data');
    });

    it('should handle setup client errors', async () => {
      const setupError = new Error('Client setup failed');
      (setupJQuantsClient as ReturnType<typeof vi.fn>).mockRejectedValue(setupError);
      const options = { ...mockFetchOptions, output: './data' };

      await fetchTOPIX(options);

      expect(mockSpinnerFns.fail).toHaveBeenCalled();
      expect(handleApiError).toHaveBeenCalledWith(setupError, 'Failed to fetch TOPIX data');
    });
  });

  describe('parameter handling', () => {
    it('should only include provided parameters', async () => {
      mockJQuantsClient.getTOPIX.mockResolvedValue(mockTOPIXData);
      const options = {
        from: '2025-01-01',
        output: './data',
        csv: false,
        json: true,
      };

      await fetchTOPIX(options);

      expect(mockJQuantsClient.getTOPIX).toHaveBeenCalledWith({
        from: '2025-01-01',
      });
    });

    it('should handle options with only to date', async () => {
      mockJQuantsClient.getTOPIX.mockResolvedValue(mockTOPIXData);
      const options = {
        to: '2025-01-31',
        output: './data',
        csv: false,
        json: true,
      };

      await fetchTOPIX(options);

      expect(mockJQuantsClient.getTOPIX).toHaveBeenCalledWith({
        to: '2025-01-31',
      });
    });
  });
});
